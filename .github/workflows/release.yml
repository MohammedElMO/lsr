name: Release Crate + CLI(lsrs)

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write
  packages: write

jobs:
  test:
    uses: ./.github/workflows/test.yml

  build-release:
    needs: test
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            suffix: ""
            archive_cmd: "tar czf"
            archive_ext: "tar.gz"
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            suffix: ".exe"
            archive_cmd: "7z a"
            archive_ext: "zip"
          - os: macos-13
            target: x86_64-apple-darwin
            suffix: ""
            archive_cmd: "tar czf"
            archive_ext: "tar.gz"
          - os: macos-14
            target: aarch64-apple-darwin
            suffix: ""
            archive_cmd: "tar czf"
            archive_ext: "tar.gz"

    runs-on: ${{ matrix.os }}
    timeout-minutes: 45

    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache Rust dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-${{ matrix.target }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.target }}-cargo-
            ${{ runner.os }}-cargo-

      - name: Get expected binary name
        id: expected_binary
        shell: bash
        run: |
          echo "=== Extracting binary name from Cargo.toml ==="
          
          # Try to get binary name from [[bin]] section first
          BINARY_NAME=""
          
          if grep -q "^\[\[bin\]\]" Cargo.toml; then
            echo "Found [[bin]] section"
            # Extract name from [[bin]] section
            BINARY_NAME=$(awk '
              /^\[\[bin\]\]/ { in_bin = 1; next }
              /^\[/ && !/^\[\[bin\]\]/ { in_bin = 0; next }
              in_bin && /^name = / { 
                gsub(/name = "|"/, ""); 
                gsub(/[ \t\r\n]/, "");
                print $0;
                exit
              }
            ' Cargo.toml)
          fi
          
          # Fallback to package name
          if [[ -z "$BINARY_NAME" ]]; then
            echo "No [[bin]] section or name found, using package name"
            BINARY_NAME=$(grep "^name = " Cargo.toml | head -1 | sed 's/name = "//' | sed 's/"//' | tr -d ' ')
          fi
          
          echo "Expected binary name: $BINARY_NAME"
          echo "expected_name=$BINARY_NAME" >> $GITHUB_OUTPUT

      - name: Debug Cargo.toml
        run: |
          echo "=== Cargo.toml content ==="
          cat Cargo.toml
          echo "=========================="
          
          echo "Expected binary: ${{ steps.expected_binary.outputs.expected_name }}"

      - name: Build binary
        shell: bash
        run: |
          echo "Building for target: ${{ matrix.target }}"
          
          # Build with verbose output to see what's happening
          RUST_BACKTRACE=1 cargo build --release --target ${{ matrix.target }} --verbose
          
          echo "=== Build completed, checking output ==="
          
          # List everything in the target directory
          echo "Contents of target/${{ matrix.target }}/release/:"
          ls -la target/${{ matrix.target }}/release/ || true
          
          # Look for any executable files
          echo "=== Looking for executables ==="
          find target/${{ matrix.target }}/release/ -type f -executable 2>/dev/null || true
          
          # On Windows, look for .exe files
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            echo "=== Looking for .exe files ==="
            find target/${{ matrix.target }}/release/ -name "*.exe" 2>/dev/null || true
          fi

      - name: Identify binary name
        shell: bash
        id: binary_name
        run: |
          echo "=== Identifying actual binary name ==="
          
          cd target/${{ matrix.target }}/release/
          
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            # Look for .exe files, excluding deps and build artifacts
            BINARY=$(find . -maxdepth 1 -name "*.exe" -not -name "*-*" | head -1 | sed 's|^./||')
            if [[ -z "$BINARY" ]]; then
              # Fallback: look for any .exe file
              BINARY=$(find . -name "*.exe" | head -1 | sed 's|^./||')
            fi
          else
            # For Unix systems, look for files with executable permissions
            # Use a more portable approach than -executable
            BINARY=""
          
            # First try: look for files without hyphens (main binaries)
            for file in *; do
              if [[ -f "$file" && ! "$file" == *"-"* && -x "$file" ]]; then
                BINARY="$file"
                break
              fi
            done
          
            # Second try: look for any executable file
            if [[ -z "$BINARY" ]]; then
              for file in *; do
                if [[ -f "$file" && -x "$file" ]]; then
                  BINARY="$file"
                  break
                fi
              done
            fi
          
            # Third try: look for files that are likely binaries by checking if they're not text
            if [[ -z "$BINARY" ]]; then
              for file in *; do
                if [[ -f "$file" && ! "$file" == *"."* ]]; then
                  # Check if it's a binary file (not text)
                  if file "$file" | grep -q -E "(executable|binary)"; then
                    BINARY="$file"
                    chmod +x "$file"  # Make sure it's executable
                    break
                  fi
                fi
              done
            fi
          
            # Final fallback: use the expected binary name from Cargo.toml
            if [[ -z "$BINARY" ]]; then
              EXPECTED_NAME="${{ steps.expected_binary.outputs.expected_name }}"
              echo "Trying expected binary name: $EXPECTED_NAME"
          
              if [[ -f "$EXPECTED_NAME" ]]; then
                BINARY="$EXPECTED_NAME"
                chmod +x "$EXPECTED_NAME"
                echo "Found expected binary: $EXPECTED_NAME"
              elif [[ -f "${EXPECTED_NAME}${{ matrix.suffix }}" ]]; then
                BINARY="${EXPECTED_NAME}${{ matrix.suffix }}"
                chmod +x "$BINARY" 2>/dev/null || true
                echo "Found expected binary with suffix: $BINARY"
              fi
            fi
          fi
          
          if [[ -z "$BINARY" ]]; then
            echo "❌ No binary found!"
            echo "Available files:"
            ls -la
            echo "File types:"
            for f in *; do
              if [[ -f "$f" ]]; then
                echo "$f: $(file "$f" 2>/dev/null || echo 'unknown')"
              fi
            done
            exit 1
          fi
          
          echo "✅ Found binary: $BINARY"
          echo "binary_name=$BINARY" >> $GITHUB_OUTPUT
          
          # Get the base name without extension
          BASE_NAME=$(basename "$BINARY" .exe)
          echo "base_name=$BASE_NAME" >> $GITHUB_OUTPUT
          
          # Verify it's executable/runnable
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            echo "Binary info:"
            file "$BINARY" || echo "File command not available"
          else
            echo "Binary info:"
            file "$BINARY" || echo "File command not available"
            chmod +x "$BINARY"
          
            # Double-check it's executable
            if [[ ! -x "$BINARY" ]]; then
              echo "Warning: Binary may not be executable"
              ls -la "$BINARY"
            fi
          fi

      - name: Strip binary (Unix)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          cd target/${{ matrix.target }}/release/
          BINARY="${{ steps.binary_name.outputs.binary_name }}"
          
          if [[ -f "$BINARY" ]]; then
            echo "Stripping $BINARY"
            strip "$BINARY"
            ls -la "$BINARY"
          else
            echo "Binary $BINARY not found for stripping"
            exit 1
          fi

      - name: Test binary
        shell: bash
        run: |
          cd target/${{ matrix.target }}/release/
          BINARY="${{ steps.binary_name.outputs.binary_name }}"
          
          echo "Testing binary: $BINARY"
          
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            ./"$BINARY" --version || ./"$BINARY" --help || echo "Binary exists but might not support --version/--help"
          else
            ./"$BINARY" --version || ./"$BINARY" --help || echo "Binary exists but might not support --version/--help"
          fi

      - name: Create release archive
        shell: bash
        run: |
          cd target/${{ matrix.target }}/release/
          
          BINARY="${{ steps.binary_name.outputs.binary_name }}"
          BASE_NAME="${{ steps.binary_name.outputs.base_name }}"
          TARGET="${{ matrix.target }}"
          
          echo "Creating archive for binary: $BINARY (base: $BASE_NAME)"
          
          if [[ ! -f "$BINARY" ]]; then
            echo "❌ Binary $BINARY not found"
            ls -la
            exit 1
          fi
          
          # Create archive with consistent naming
          ARCHIVE_NAME="${BASE_NAME}-${TARGET}.${{ matrix.archive_ext }}"
          
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            # Use PowerShell for Windows
            powershell -Command "Compress-Archive -Path '$BINARY' -DestinationPath '../../../$ARCHIVE_NAME'"
          else
            # Use tar for Unix systems
            tar czf "../../../$ARCHIVE_NAME" "$BINARY"
          fi
          
          cd ../../..
          
          # Verify archive was created
          if [[ -f "$ARCHIVE_NAME" ]]; then
            echo "✅ Archive created: $ARCHIVE_NAME"
            ls -la "$ARCHIVE_NAME"
          
            # Test archive contents
            if [[ "${{ runner.os }}" == "Windows" ]]; then
              powershell -Command "Get-Content -Path (Get-ChildItem '$ARCHIVE_NAME').FullName -Raw | Select-String '$BINARY'"
            else
              tar -tzf "$ARCHIVE_NAME"
            fi
          else
            echo "❌ Archive creation failed"
            exit 1
          fi

      - name: Upload release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.target }}
          path: |
            ${{ steps.binary_name.outputs.base_name }}-${{ matrix.target }}.tar.gz
            ${{ steps.binary_name.outputs.base_name }}-${{ matrix.target }}.zip
          if-no-files-found: error
          retention-days: 1

  publish-crate:
    needs: test
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: publish-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Dry run publish first
        run: cargo publish --dry-run --token ${{ secrets.CARGO_TOKEN }}

      - name: Publish to crates.io
        run: cargo publish --token ${{ secrets.CARGO_TOKEN }}

  create-github-release:
    needs: [build-release, publish-crate]
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v4

      - name: Get binary name from Cargo.toml
        id: binary_info
        run: |
          # Extract binary name - try [[bin]] section first, then package name
          if grep -q "^\[\[bin\]\]" Cargo.toml; then
            BINARY_NAME=$(awk '/^\[\[bin\]\]/{flag=1; next} /^\[/{flag=0} flag && /^name = /{gsub(/[" ]/, "", $3); print $3}' Cargo.toml | head -1)
          fi
          
          if [[ -z "$BINARY_NAME" ]]; then
            BINARY_NAME=$(grep "^name = " Cargo.toml | head -1 | cut -d'"' -f2)
          fi
          
          echo "Detected binary name: $BINARY_NAME"
          echo "binary_name=$BINARY_NAME" >> $GITHUB_OUTPUT

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Organize artifacts
        run: |
          echo "=== Downloaded artifacts ==="
          find artifacts/ -type f -exec ls -la {} \;
          
          # Move all archives to root level
          find artifacts/ -name "*.tar.gz" -exec mv {} . \;
          find artifacts/ -name "*.zip" -exec mv {} . \;
          
          echo "=== Final artifacts ==="
          ls -la *.tar.gz *.zip 2>/dev/null || echo "No archives found - this will cause the release to fail"
          
          # Count archives
          ARCHIVE_COUNT=$(ls *.tar.gz *.zip 2>/dev/null | wc -l)
          echo "Found $ARCHIVE_COUNT archives"
          
          if [[ $ARCHIVE_COUNT -eq 0 ]]; then
            echo "❌ No archives found! Release will fail."
            exit 1
          fi

      - name: Create install scripts
        run: |
          BINARY_NAME="${{ steps.binary_info.outputs.binary_name }}"
          
          # Create install.sh
          cat > install.sh << EOF
          #!/bin/bash
          set -e

          # Configuration
          REPO="MohammedElMO/lsrs"
          BINARY_NAME="$BINARY_NAME"
          VERSION="${{ github.ref_name }}"
          INSTALL_DIR="\${INSTALL_DIR:-/usr/local/bin}"

          # Colors
          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          NC='\033[0m'

          log_info() { echo -e "\${GREEN}[INFO]\${NC} \$1"; }
          log_warn() { echo -e "\${YELLOW}[WARN]\${NC} \$1"; }
          log_error() { echo -e "\${RED}[ERROR]\${NC} \$1"; }

          detect_platform() {
              local os=\$(uname -s | tr '[:upper:]' '[:lower:]')
              local arch=\$(uname -m)

              case \$arch in
                  x86_64) arch="x86_64" ;;
                  arm64|aarch64) arch="aarch64" ;;
                  *) log_error "Unsupported architecture: \$arch" && exit 1 ;;
              esac

              case \$os in
                  linux) echo "x86_64-unknown-linux-gnu" ;;
                  darwin)
                      if [[ \$arch == "aarch64" ]]; then
                          echo "aarch64-apple-darwin"
                      else
                          echo "x86_64-apple-darwin"
                      fi
                      ;;
                  *) log_error "Unsupported OS: \$os" && exit 1 ;;
              esac
          }

          main() {
              log_info "Installing \$BINARY_NAME \$VERSION..."

              for cmd in curl tar; do
                  if ! command -v \$cmd >/dev/null 2>&1; then
                      log_error "Required command not found: \$cmd"
                      exit 1
                  fi
              done

              local platform=\$(detect_platform)
              local archive_name="\$BINARY_NAME-\${platform}.tar.gz"
              local download_url="https://github.com/\$REPO/releases/download/\$VERSION/\$archive_name"

              log_info "Platform: \$platform"
              log_info "Downloading: \$download_url"

              local tmp_dir=\$(mktemp -d)
              cd "\$tmp_dir"

              if ! curl -fsSL "\$download_url" | tar xz; then
                  log_error "Failed to download or extract \$archive_name"
                  exit 1
              fi

              # The binary should be the only file in the archive
              local binary_file=\$(ls | head -1)
              if [[ ! -f "\$binary_file" ]]; then
                  log_error "No binary found in archive"
                  ls -la
                  exit 1
              fi

              chmod +x "\$binary_file"

              log_info "Installing to \$INSTALL_DIR..."
              if [[ ! -w "\$INSTALL_DIR" ]]; then
                  sudo mv "\$binary_file" "\$INSTALL_DIR/\$BINARY_NAME"
              else
                  mv "\$binary_file" "\$INSTALL_DIR/\$BINARY_NAME"
              fi

              cd - >/dev/null && rm -rf "\$tmp_dir"

              if command -v "\$BINARY_NAME" >/dev/null 2>&1; then
                  log_info "✅ Installation successful!"
                  log_info "Run '\$BINARY_NAME --help' to get started"
              else
                  log_warn "Binary installed but not in PATH"
                  log_warn "Add \$INSTALL_DIR to PATH or run:"
                  log_warn "  export PATH=\"\$INSTALL_DIR:\\\$PATH\""
              fi
          }

          main "\$@"
          EOF

          # Create install.ps1
          cat > install.ps1 << EOF
          param([string]\$InstallDir = "\$env:USERPROFILE\\.local\\bin")

          \$REPO = "MohammedElMO/lsrs"
          \$BINARY_NAME = "$BINARY_NAME"
          \$VERSION = "${{ github.ref_name }}"

          function Write-Info { param([string]\$Message); Write-Host "[INFO] \$Message" -ForegroundColor Green }
          function Write-Error { param([string]\$Message); Write-Host "[ERROR] \$Message" -ForegroundColor Red }

          Write-Info "Installing \$BINARY_NAME \$VERSION..."

          \$platform = "x86_64-pc-windows-msvc"
          \$archiveName = "\$BINARY_NAME-\$platform.zip"
          \$downloadUrl = "https://github.com/\$REPO/releases/download/\$VERSION/\$archiveName"

          \$tempDir = Join-Path \$env:TEMP ([System.Guid]::NewGuid().ToString())

          try {
              New-Item -ItemType Directory -Path \$tempDir -Force | Out-Null
          
              \$archivePath = Join-Path \$tempDir \$archiveName
              Invoke-WebRequest -Uri \$downloadUrl -OutFile \$archivePath
              Expand-Archive -Path \$archivePath -DestinationPath \$tempDir -Force

              # Find the binary (should be the only .exe file)
              \$binaryPath = Get-ChildItem -Path \$tempDir -Filter "*.exe" | Select-Object -First 1 -ExpandProperty FullName

              if (-not \$binaryPath) {
                  Write-Error "No binary found in archive"
                  exit 1
              }

              if (-not (Test-Path \$InstallDir)) {
                  New-Item -ItemType Directory -Path \$InstallDir -Force | Out-Null
              }

              \$installPath = Join-Path \$InstallDir "\$BINARY_NAME.exe"
              Copy-Item \$binaryPath \$installPath -Force

              Write-Info "✅ Installation successful!"
              Write-Info "Run '\$BINARY_NAME --help' to get started"

          } catch {
              Write-Error "Installation failed: \$(\$_.Exception.Message)"
              exit 1
          } finally {
              if (Test-Path \$tempDir) {
                  Remove-Item \$tempDir -Recurse -Force
              }
          }
          EOF

          chmod +x install.sh
          
          echo "Created install scripts for binary: $BINARY_NAME"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          name: Release ${{ github.ref_name }}
          draft: false
          prerelease: false
          fail_on_unmatched_files: true
          files: |
            *.tar.gz
            *.zip
            install.sh
            install.ps1
          body: |
            ## Installation

            ### Quick Install (Recommended)
            
            **Linux/macOS:**
            ```bash
            curl -sSL https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/install.sh | bash
            ```
            
            **Windows (PowerShell):**
            ```powershell
            iwr https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/install.ps1 | iex
            ```

            ### Via Cargo
            ```bash
            cargo install lsrs
            ```

            ### Manual Download
            Download the appropriate binary for your platform from the assets below and extract to your PATH.

            ### Custom Install Location
            
            **Linux/macOS:**
            ```bash
            INSTALL_DIR=~/.local/bin curl -sSL https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/install.sh | bash
            ```
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}